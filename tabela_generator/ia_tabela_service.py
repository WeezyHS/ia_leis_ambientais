#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Servi√ßo de IA direcionada para gera√ß√£o de tabelas/planilhas das leis ambientais
Utiliza OpenAI API de forma program√°tica para organizar dados em tabelas
Inclui TODAS as fontes de dados: Leis Estaduais, Power BI, COEMA, ABNT, CONAMA, etc.
"""

import json
import pandas as pd
from pathlib import Path
from typing import Dict, List, Any, Optional
import openai
from openai import OpenAI
import os
import sys
from dotenv import load_dotenv

# Adicionar o diret√≥rio app ao path para importar servi√ßos
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'app'))

# Carregar vari√°veis de ambiente
load_dotenv()

class IATabela:
    """
    IA direcionada para gera√ß√£o de tabelas organizadas de TODAS as fontes de dados ambientais
    """
    
    def __init__(self):
        """Inicializa o servi√ßo de IA para tabelas com todas as fontes"""
        self.api_key = os.getenv('OPENAI_API_KEY')
        if not self.api_key:
            raise ValueError("OPENAI_API_KEY n√£o encontrada no arquivo .env")
        

        
        # Carregar dados APENAS do Pinecone
        self.todas_fontes_data = self._carregar_todas_fontes()
        

    

    

    

    

    
    def _carregar_todas_fontes(self) -> List[Dict]:
        """Carrega dados APENAS do Pinecone como fonte √∫nica"""
        todas_fontes = []
        
        try:
            # √öNICA FONTE: Dados do Pinecone
            print("üéØ Carregando dados APENAS do Pinecone como fonte √∫nica...")
            dados_pinecone = self._carregar_dados_pinecone()
            todas_fontes.extend(dados_pinecone)
            
            print(f"‚úÖ {len(todas_fontes)} documentos carregados APENAS do Pinecone")
            return todas_fontes
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar dados do Pinecone: {e}")
            # Retorna lista vazia em caso de erro
            return []
    
    def _carregar_dados_pinecone(self) -> List[Dict]:
        """Carrega apenas dados reais dos namespaces do Pinecone e arquivos JSON locais"""
        dados_pinecone = []
        
        try:
            from services.pinecone_service import pinecone_index
            
            # Obter estat√≠sticas dos namespaces
            stats = pinecone_index.describe_index_stats()
            print(f"üìä Namespaces dispon√≠veis no Pinecone: {list(stats.namespaces.keys())}")
            
            # Buscar dados reais de ABNT se dispon√≠vel no namespace
            if "abnt-normas" in stats.namespaces:
                abnt_count = stats.namespaces["abnt-normas"].vector_count
                print(f"üìã Encontradas {abnt_count} normas ABNT no Pinecone")
                
                # Buscar dados reais das normas ABNT (limitado para performance)
                try:
                    query_response = pinecone_index.query(
                        namespace="abnt-normas",
                        vector=[0.0] * 1536,  # Vector dummy para busca
                        top_k=min(10, abnt_count),
                        include_metadata=True
                    )
                    
                    for match in query_response.matches:
                        metadata = match.metadata or {}
                        dados_pinecone.append({
                            "fonte": "ABNT - Pinecone",
                            "tipo": "Norma T√©cnica",
                            "titulo": metadata.get("titulo", "Norma ABNT"),
                            "descricao": metadata.get("descricao", "Norma t√©cnica brasileira")[:200] + "...",
                            "conteudo": metadata.get("conteudo", "Especifica√ß√µes t√©cnicas")[:200] + "...",
                            "categoria": "Norma T√©cnica",
                            "jurisdicao": "Nacional",
                            "data_indexacao": metadata.get("data_indexacao", "2025-01-07"),
                            "fonte_dados": "Pinecone - Dados Reais"
                        })
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao buscar normas ABNT: {e}")
            
            # Buscar dados reais do namespace principal (onde est√£o as leis)
            for namespace in stats.namespaces:
                if namespace not in ["abnt-normas"] and stats.namespaces[namespace].vector_count > 0:
                    print(f"üìã Namespace '{namespace}' com {stats.namespaces[namespace].vector_count} documentos")
                    
                    # Buscar documentos do namespace principal
                    try:
                        query_response = pinecone_index.query(
                            namespace=namespace if namespace != "" else None,
                            vector=[0.0] * 1536,  # Vector dummy para busca
                            top_k=min(50, stats.namespaces[namespace].vector_count),  # Buscar mais documentos
                            include_metadata=True
                        )
                        
                        for match in query_response.matches:
                            metadata = match.metadata or {}
                            
                            # Extrair dados do documento
                            titulo = metadata.get("titulo", metadata.get("title", "Documento"))
                            descricao = metadata.get("descricao", metadata.get("ementa", metadata.get("content", "")))
                            tipo_doc = metadata.get("tipo", metadata.get("type", "Lei"))
                            jurisdicao = metadata.get("jurisdicao", metadata.get("jurisdiction", "Federal"))
                            
                            dados_pinecone.append({
                                "fonte": f"Pinecone - {namespace if namespace else 'Principal'}",
                                "tipo": self._mapear_tipo_documento(tipo_doc),
                                "titulo": titulo,
                                "descricao": descricao[:300] + "..." if len(descricao) > 300 else descricao,
                                "ementa": descricao,  # Para compatibilidade com leis federais
                                "conteudo": metadata.get("conteudo", metadata.get("content", descricao))[:200] + "...",
                                "categoria": "Legisla√ß√£o Ambiental",
                                "jurisdicao": jurisdicao,
                                "data_indexacao": metadata.get("data_indexacao", "2025-01-07"),
                                "fonte_dados": "Pinecone - Dados Reais",
                                "vigencia": "‚úÖ Vigente"  # Assumir vigente para dados do Pinecone
                            })
                            
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erro ao buscar dados do namespace '{namespace}': {e}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao acessar Pinecone: {e}")
        
        # Nota: Todos os dados (incluindo COEMA, IBAMA, ICMBio) devem estar indexados no Pinecone
        print(f"üìä Total de {len(dados_pinecone)} documentos carregados APENAS do Pinecone")
        
        return dados_pinecone
    
    def _mapear_tipo_documento(self, tipo_doc: str) -> str:
        """Mapeia tipos de documento para categorias padronizadas"""
        tipo_doc = tipo_doc.lower() if tipo_doc else ""
        
        if "lei" in tipo_doc:
            return "Lei"
        elif "decreto" in tipo_doc:
            return "Decreto"
        elif "resolu√ß√£o" in tipo_doc or "resolucao" in tipo_doc:
            return "Resolu√ß√£o"
        elif "portaria" in tipo_doc:
            return "Portaria"
        elif "instru√ß√£o" in tipo_doc or "instrucao" in tipo_doc:
            return "Instru√ß√£o Normativa"
        elif "norma" in tipo_doc:
            return "Norma"
        elif "constitui√ß√£o" in tipo_doc or "constituicao" in tipo_doc:
            return "Constitui√ß√£o"
        else:
            return "Legisla√ß√£o"

    def _estrutura_quadro_padrao(self, municipio: str, grupo_atividade: str) -> Dict[str, Any]:
        """Retorna estrutura padr√£o para quadro-resumo de legisla√ß√µes"""
        return {
            "titulo": f"Quadro-Resumo de Legisla√ß√µes Ambientais - {grupo_atividade} em {municipio}",
            "municipio": municipio,
            "grupo_atividade": grupo_atividade,
            "descricao": f"Legisla√ß√µes ambientais aplic√°veis para atividades de {grupo_atividade} no munic√≠pio de {municipio}",
            "dados": [],
            "colunas": [
                "esfera",
                "titulo_legislacao", 
                "vigencia",
                "descricao_resumida",
                "aplicabilidade",
                "fonte_dados"
            ],
            "filtros_sugeridos": {
                "esfera": ["Federal", "Estadual", "Municipal"],
                "vigencia": ["Vigente", "Revogada", "Alterada"]
            },
            "ordenacao_padrao": "esfera"
        }

    def popular_quadro_resumo(self, estrutura: Dict, municipio: str, grupo_atividade: str, esferas: List[str], limite_por_esfera: int = 10) -> pd.DataFrame:
        """
        Popula o quadro-resumo com legisla√ß√µes espec√≠ficas para o munic√≠pio e atividade
        
        Args:
            estrutura: Estrutura do quadro-resumo
            municipio: Munic√≠pio do empreendimento
            grupo_atividade: Grupo de atividade
            esferas: Lista de esferas legais a incluir
            limite_por_esfera: M√°ximo de legisla√ß√µes por esfera
        
        Returns:
            DataFrame com o quadro-resumo populado
        """
        try:
            dados_quadro = []
            
            # Gerar dados para cada esfera solicitada
            for esfera in esferas:
                legislacoes_esfera = self._obter_legislacoes_por_esfera(
                    esfera, municipio, grupo_atividade, limite_por_esfera
                )
                dados_quadro.extend(legislacoes_esfera)
            
            # Criar DataFrame
            df_quadro = pd.DataFrame(dados_quadro)
            
            # Ordenar por esfera (Federal, Estadual, Municipal) - com tratamento de erro
            if not df_quadro.empty and 'esfera' in df_quadro.columns:
                ordem_esferas = {"Federal": 1, "Estadual": 2, "Municipal": 3}
                df_quadro['ordem_esfera'] = df_quadro['esfera'].map(ordem_esferas)
                df_quadro = df_quadro.sort_values('ordem_esfera').drop('ordem_esfera', axis=1)
            else:
                print(f"‚ö†Ô∏è DataFrame vazio ou sem coluna 'esfera'. Colunas dispon√≠veis: {list(df_quadro.columns) if not df_quadro.empty else 'Nenhuma'}")
                # Se n√£o h√° dados, criar um DataFrame com estrutura m√≠nima
                if df_quadro.empty:
                    df_quadro = pd.DataFrame([{
                        "esfera": "Sistema",
                        "titulo_legislacao": "Nenhuma legisla√ß√£o encontrada",
                        "vigencia": "N/A",
                        "descricao_resumida": f"Nenhuma legisla√ß√£o espec√≠fica para {grupo_atividade} foi encontrada nos dados indexados",
                        "aplicabilidade": "Consulte legisla√ß√£o espec√≠fica para sua atividade",
                        "fonte_dados": "Sistema - Dados N√£o Encontrados"
                    }])
            
            return df_quadro
            
        except Exception as e:
            print(f"‚ùå Erro ao popular quadro-resumo: {e}")
            # Retorna DataFrame vazio em caso de erro
            return pd.DataFrame([{
                "esfera": "Sistema",
                "titulo_legislacao": "Erro no sistema",
                "vigencia": "N/A",
                "descricao_resumida": "N√£o foi poss√≠vel carregar dados do Pinecone",
                "aplicabilidade": "Sistema temporariamente indispon√≠vel",
                "fonte_dados": "Erro - Dados N√£o Dispon√≠veis"
            }])

    def _obter_legislacoes_por_esfera(self, esfera: str, municipio: str, grupo_atividade: str, limite: int) -> List[Dict]:
        """Obt√©m legisla√ß√µes espec√≠ficas para uma esfera legal"""
        
        if esfera == "Federal":
            return self._legislacoes_federais(grupo_atividade, limite)
        elif esfera == "Estadual":
            return self._legislacoes_estaduais(municipio, grupo_atividade, limite)
        elif esfera == "Municipal":
            return self._legislacoes_municipais(municipio, grupo_atividade, limite)
        else:
            return []

    def _verificar_vigencia_legislacao(self, legislacao: Dict) -> bool:
        """
        ‚ö†Ô∏è PREMISSA OBRIGAT√ìRIA: Verifica se a legisla√ß√£o est√° VIGENTE
        Retorna True apenas para legisla√ß√µes vigentes, omite revogadas/substitu√≠das
        """
        vigencia = legislacao.get("vigencia", "").lower()
        titulo = legislacao.get("titulo_legislacao", "").lower()
        
        # Palavras que indicam legisla√ß√£o N√ÉO vigente
        palavras_nao_vigentes = [
            "revogad", "substitu√≠d", "alterada por", "derrogad", 
            "ab-rogad", "suspenso", "cancelad", "anulad"
        ]
        
        # Verificar se cont√©m indicadores de n√£o vig√™ncia
        for palavra in palavras_nao_vigentes:
            if palavra in vigencia or palavra in titulo:
                return False
        
        # Aceitar apenas legisla√ß√µes explicitamente marcadas como vigentes
        return "vigente" in vigencia or "‚úÖ" in vigencia
    
    def _legislacoes_federais(self, grupo_atividade: str, limite: int) -> List[Dict]:
        """Retorna APENAS legisla√ß√µes federais REAIS do Pinecone relacionadas ao grupo de atividade"""
        
        # üéØ FILTRO EXPANDIDO: Palavras-chave mais abrangentes por atividade (baseado em dados reais do Pinecone)
        palavras_chave_federais = {
            "Agricultura": ["agric", "rural", "agropec", "plantio", "cultivo", "irriga√ß√£o", "atividade rural", "produtor rural", "√°rea de preserva√ß√£o", "vegeta√ß√£o nativa"],
            "Pecu√°ria": ["pecu√°r", "gado", "bovino", "su√≠no", "av√≠cola", "frigor√≠fico", "abate", "rebanho", "florestal", "pastagem", "cria√ß√£o de animais", "atividade rural"],
            "Ind√∫stria": ["industr", "f√°brica", "manufatur", "produ√ß√£o industrial", "polui√ß√£o industrial", "res√≠duo", "emiss√£o", "efluente"],
            "Minera√ß√£o": ["miner", "lavra", "garimpo", "extra√ß√£o mineral", "jazida", "meio ambiente", "degrada√ß√£o", "recupera√ß√£o"],
            "Saneamento": ["saneamento", "√°gua", "esgoto", "res√≠duo", "tratamento", "abastecimento", "res√≠duos s√≥lidos", "lixo", "coleta"],
            "Energia": ["energia", "el√©trica", "hidrel√©trica", "solar", "e√≥lica", "usina", "gera√ß√£o", "meio ambiente", "impacto ambiental"],
            "Transporte": ["transporte", "rodovi√°rio", "ferrovi√°rio", "aquavi√°rio", "portu√°rio", "aeroportu√°rio", "log√≠stica", "combust√≠vel", "emiss√£o veicular", "polui√ß√£o atmosf√©rica"],
            "Constru√ß√£o Civil": ["constru√ß√£o", "edifica√ß√£o", "obra", "canteiro", "demoli√ß√£o", "res√≠duo da constru√ß√£o", "entulho", "supress√£o vegetal", "movimenta√ß√£o de terra"],
            "Servi√ßos": ["servi√ßos", "presta√ß√£o de servi√ßos", "atividade terci√°ria", "estabelecimento comercial", "gera√ß√£o de res√≠duos", "efluente sanit√°rio"],
            "Com√©rcio": ["com√©rcio", "comercial", "varejo", "atacado", "estabelecimento", "res√≠duo comercial", "embalagem", "descarte"],
            "Outros": ["atividade", "empreendimento", "projeto", "desenvolvimento", "sustent√°vel", "impacto", "mitiga√ß√£o", "compensa√ß√£o", "monitoramento"]
        }
        
        # üö´ FILTRO RESTRITIVO: Apenas palavras espec√≠ficas para a atividade
        palavras_atividade = palavras_chave_federais.get(grupo_atividade, [])
        
        if not palavras_atividade:
            print(f"‚ö†Ô∏è Nenhuma palavra-chave espec√≠fica mapeada para '{grupo_atividade}'")
            return []
        
        legislacoes_federais = []
        
        # üîç BUSCAR NAS LEIS REAIS CARREGADAS DE TODAS AS FONTES (INCLUINDO PINECONE)
        for lei in self.todas_fontes_data:
            # Filtrar apenas leis federais
            jurisdicao = lei.get("jurisdicao", "").lower()
            if "federal" not in jurisdicao:
                continue
            titulo = lei.get("titulo", "")
            ementa = lei.get("ementa", "")
            titulo_ementa = (titulo + " " + ementa).lower()
            
            # üéØ VERIFICA√á√ÉO RIGOROSA: A lei deve conter pelo menos uma palavra-chave espec√≠fica
            if any(palavra in titulo_ementa for palavra in palavras_atividade):
                aplicabilidade = self._gerar_aplicabilidade_federal_real(lei, grupo_atividade)
                
                legislacao_formatada = {
                    "esfera": "Federal",
                    "titulo_legislacao": titulo,
                    "vigencia": "‚úÖ Vigente",
                    "descricao_resumida": ementa[:200] + "..." if len(ementa) > 200 else ementa,
                    "aplicabilidade": aplicabilidade,
                    "fonte_dados": "Pinecone - Dados Reais"  # üîç TRANSPAR√äNCIA DE ORIGEM
                }
                
                legislacoes_federais.append(legislacao_formatada)
        
        print(f"üéØ Filtro restritivo aplicado: {len(legislacoes_federais)} leis federais REAIS para '{grupo_atividade}'")
        print(f"üìä Fonte: 100% dados reais do Pinecone")
        return legislacoes_federais[:limite]
    
    def _gerar_aplicabilidade_federal_real(self, lei: Dict, grupo_atividade: str) -> str:
        """Gera o texto da coluna "aplicabilidade" da tabela, baseado EXCLUSIVAMENTE nos dados reais da lei"""
        
        titulo = lei.get("titulo", "").lower()
        ementa = lei.get("ementa", "").lower()
        
        # üîç AN√ÅLISE BASEADA EXCLUSIVAMENTE EM DADOS REAIS
        # Extrair informa√ß√µes relevantes da ementa real da lei
        if "meio ambiente" in ementa and "licenciamento" in ementa:
            return f"Licenciamento ambiental aplic√°vel a atividades de {grupo_atividade.lower()} conforme ementa da lei"
        elif "florestal" in ementa or "floresta" in ementa:
            return f"Regulamenta√ß√£o florestal aplic√°vel a atividades de {grupo_atividade.lower()} conforme ementa da lei"
        elif "crimes" in ementa and "ambiental" in ementa:
            return f"Define crimes ambientais aplic√°veis a {grupo_atividade.lower()} conforme ementa da lei"
        elif "res√≠duos" in ementa or "res√≠duo" in ementa:
            return f"Gest√£o de res√≠duos aplic√°vel a atividades de {grupo_atividade.lower()} conforme ementa da lei"
        elif "√°gua" in ementa or "h√≠drico" in ementa:
            return f"Gest√£o de recursos h√≠dricos aplic√°vel a atividades de {grupo_atividade.lower()} conforme ementa da lei"
        elif "conserva√ß√£o" in ementa or "prote√ß√£o" in ementa:
            return f"Conserva√ß√£o ambiental aplic√°vel a atividades de {grupo_atividade.lower()} conforme ementa da lei"
        else:
            # üö® TRANSPAR√äNCIA TOTAL: Usar apenas dados reais da ementa
            ementa_resumida = ementa[:100] + "..." if len(ementa) > 100 else ementa
            return f"Aplic√°vel a atividades de {grupo_atividade.lower()}: {ementa_resumida}"

    def _legislacoes_estaduais(self, municipio: str, grupo_atividade: str, limite: int) -> List[Dict]:
        """Retorna APENAS legisla√ß√µes estaduais REAIS do Pinecone relacionadas ao grupo de atividade"""
        
        # üéØ FILTRO EXPANDIDO: Palavras-chave mais abrangentes por atividade (baseado em dados reais do Pinecone)
        palavras_chave_restritivas = {
            "Agricultura": ["licenciamento ambiental", "gest√£o ambiental", "sustentabilidade ambiental", "zoneamento ambiental", "passivo ambiental", "impactos ambientais", "gest√£o de res√≠duos s√≥lidos", "res√≠duos perigosos", "compostagem", "aterro sanit√°rio", "reciclagem", "reutiliza√ß√£o", "polui√ß√£o difusa", "contamina√ß√£o do solo", "recursos h√≠dricos", "bacia hidrogr√°fica", "outorga de uso da √°gua", "√≠ndice de qualidade da √°gua", "eutrofiza√ß√£o", "tratamento de efluentes", "esgotamento sanit√°rio", "√°gua subterr√¢nea", "emiss√µes atmosf√©ricas", "material particulado", "biodiversidade", "fragmenta√ß√£o de habitats", "corredores ecol√≥gicos", "plano de gerenciamento de res√≠duos s√≥lidos", "invent√°rio florestal"],
            "Pecu√°ria": ["pecu√°r", "gado", "bovino", "su√≠no", "av√≠cola", "frigor√≠fico", "abate", "rebanho", "pastagem", "cria√ß√£o de animais", "atividade rural", "ambiental", "meio ambiente", "recursos", "licenciamento"],
            "Ind√∫stria": ["industr", "f√°brica", "manufatur", "produ√ß√£o industrial", "polui√ß√£o industrial", "emiss√£o", "efluente", "ambiental", "meio ambiente", "licenciamento"],
            "Minera√ß√£o": ["miner", "lavra", "garimpo", "extra√ß√£o mineral", "jazida", "degrada√ß√£o", "recupera√ß√£o", "ambiental", "meio ambiente", "licenciamento"],
            "Saneamento": ["saneamento", "√°gua", "esgoto", "res√≠duo", "tratamento", "abastecimento", "lixo", "coleta", "ambiental", "meio ambiente", "recursos h√≠dricos"],
            "Energia": ["energia", "el√©trica", "hidrel√©trica", "solar", "e√≥lica", "usina", "gera√ß√£o", "impacto ambiental", "ambiental", "meio ambiente", "licenciamento"],
            "Transporte": ["transporte", "rodovi√°rio", "ferrovi√°rio", "aquavi√°rio", "portu√°rio", "aeroportu√°rio", "log√≠stica", "combust√≠vel", "emiss√£o veicular", "polui√ß√£o atmosf√©rica", "ru√≠do", "impacto vi√°rio", "ambiental", "meio ambiente", "licenciamento"],
            "Constru√ß√£o Civil": ["constru√ß√£o", "edifica√ß√£o", "obra", "canteiro", "demoli√ß√£o", "res√≠duo da constru√ß√£o", "entulho", "supress√£o vegetal", "movimenta√ß√£o de terra", "drenagem", "impermeabiliza√ß√£o", "ambiental", "meio ambiente", "licenciamento"],
            "Servi√ßos": ["servi√ßos", "presta√ß√£o de servi√ßos", "atividade terci√°ria", "estabelecimento comercial", "gera√ß√£o de res√≠duos", "efluente sanit√°rio", "consumo de √°gua", "energia el√©trica", "ambiental", "meio ambiente", "licenciamento"],
            "Com√©rcio": ["com√©rcio", "comercial", "varejo", "atacado", "estabelecimento", "res√≠duo comercial", "embalagem", "descarte", "consumo", "sustentabilidade", "ambiental", "meio ambiente", "licenciamento"],
            "Outros": ["atividade", "empreendimento", "projeto", "desenvolvimento", "sustent√°vel", "impacto", "mitiga√ß√£o", "compensa√ß√£o", "monitoramento", "controle", "ambiental", "meio ambiente", "licenciamento"]
        }
        
        # üö´ FILTRO RESTRITIVO: Apenas palavras espec√≠ficas para a atividade
        palavras_atividade = palavras_chave_restritivas.get(grupo_atividade, [])
        
        if not palavras_atividade:
            print(f"‚ö†Ô∏è Nenhuma palavra-chave espec√≠fica mapeada para '{grupo_atividade}'")
            return []
        
        legislacoes_estaduais = []
        
        # üîç BUSCAR NAS LEIS REAIS CARREGADAS DE TODAS AS FONTES (INCLUINDO PINECONE)
        for lei in self.todas_fontes_data:
            # Filtrar apenas leis estaduais (incluindo "Estadual - Tocantins")
            jurisdicao = lei.get("jurisdicao", "").lower()
            if "estadual" not in jurisdicao:
                continue
            titulo_desc = (lei.get("titulo", "") + " " + lei.get("descricao", "")).lower()
            
            # üéØ VERIFICA√á√ÉO RIGOROSA: A lei deve conter pelo menos uma palavra-chave espec√≠fica
            if any(palavra in titulo_desc for palavra in palavras_atividade):
                legislacoes_estaduais.append({
                    "esfera": "Estadual",
                    "titulo_legislacao": lei.get("titulo", "Lei Estadual"),
                    "vigencia": "‚úÖ Vigente",
                    "descricao_resumida": lei.get("descricao", "")[:150] + "..." if len(lei.get("descricao", "")) > 150 else lei.get("descricao", ""),
                    "aplicabilidade": f"Aplic√°vel especificamente a atividades de {grupo_atividade.lower()} no estado do Tocantins",
                    "fonte_dados": "Pinecone - Dados Reais"  # üîç TRANSPAR√äNCIA DE ORIGEM
                })
        
        # ‚úÖ Usando apenas dados reais carregados do Pinecone
        # ‚úÖ AGORA USA APENAS DADOS REAIS DO PINECONE
        
        # ‚ö†Ô∏è APLICAR FILTRO DE VIG√äNCIA OBRIGAT√ìRIO
        legislacoes_vigentes = [
            leg for leg in legislacoes_estaduais 
            if self._verificar_vigencia_legislacao(leg)
        ]
        
        print(f"üéØ Filtro restritivo aplicado: {len(legislacoes_vigentes)} leis estaduais REAIS para '{grupo_atividade}'")
        print(f"üìä Fonte: 100% dados reais do Pinecone")
        return legislacoes_vigentes[:limite]

    def _legislacoes_municipais(self, municipio: str, grupo_atividade: str, limite: int) -> List[Dict]:
        """Retorna APENAS legisla√ß√µes municipais REAIS do Pinecone relacionadas ao grupo de atividade"""
        
        # üéØ FILTRO EXPANDIDO: Palavras-chave mais abrangentes por atividade (baseado em dados reais do Pinecone)
        palavras_chave_municipais = {
            "Agricultura": ["licenciamento ambiental", "gest√£o ambiental", "sustentabilidade ambiental", "zoneamento ambiental", "passivo ambiental", "impactos ambientais", "gest√£o de res√≠duos s√≥lidos", "res√≠duos perigosos", "compostagem", "aterro sanit√°rio", "reciclagem", "reutiliza√ß√£o", "polui√ß√£o difusa", "contamina√ß√£o do solo", "recursos h√≠dricos", "bacia hidrogr√°fica", "outorga de uso da √°gua", "√≠ndice de qualidade da √°gua", "eutrofiza√ß√£o", "tratamento de efluentes", "esgotamento sanit√°rio", "√°gua subterr√¢nea", "emiss√µes atmosf√©ricas", "material particulado", "biodiversidade", "fragmenta√ß√£o de habitats", "corredores ecol√≥gicos", "plano de gerenciamento de res√≠duos s√≥lidos", "invent√°rio florestal"],
            "Pecu√°ria": ["pecu√°r", "gado", "bovino", "su√≠no", "av√≠cola", "sanit√°rio", "plano diretor", "pastagem", "cria√ß√£o de animais", "atividade rural", "ambiental", "meio ambiente", "recursos", "licenciamento"],
            "Ind√∫stria": ["industr", "f√°brica", "manufatur", "zoneamento industrial", "obras", "plano diretor", "emiss√£o", "efluente", "ambiental", "meio ambiente", "licenciamento"],
            "Minera√ß√£o": ["miner", "lavra", "garimpo", "extra√ß√£o", "plano diretor", "degrada√ß√£o", "recupera√ß√£o", "ambiental", "meio ambiente", "licenciamento"],
            "Saneamento": ["saneamento", "√°gua", "esgoto", "res√≠duo", "abastecimento", "plano diretor", "lixo", "coleta", "ambiental", "meio ambiente", "recursos h√≠dricos"],
            "Energia": ["energia", "el√©trica", "renov√°vel", "solar", "e√≥lica", "plano diretor", "impacto ambiental", "ambiental", "meio ambiente", "licenciamento"],
            "Transporte": ["transporte", "tr√¢nsito", "mobilidade urbana", "plano diretor", "sistema vi√°rio", "polui√ß√£o sonora", "emiss√£o veicular", "ambiental", "meio ambiente", "licenciamento"],
            "Constru√ß√£o Civil": ["constru√ß√£o", "edifica√ß√£o", "obra", "alvar√°", "plano diretor", "c√≥digo de obras", "res√≠duo da constru√ß√£o", "supress√£o vegetal", "ambiental", "meio ambiente", "licenciamento"],
            "Servi√ßos": ["servi√ßos", "estabelecimento", "atividade econ√¥mica", "plano diretor", "zoneamento", "gera√ß√£o de res√≠duos", "ambiental", "meio ambiente", "licenciamento"],
            "Com√©rcio": ["com√©rcio", "comercial", "estabelecimento", "atividade econ√¥mica", "plano diretor", "zoneamento comercial", "res√≠duo comercial", "ambiental", "meio ambiente", "licenciamento"],
            "Outros": ["atividade", "empreendimento", "projeto", "plano diretor", "zoneamento", "uso do solo", "impacto", "ambiental", "meio ambiente", "licenciamento"]
        }
        
        # üö´ FILTRO RESTRITIVO: Apenas palavras espec√≠ficas para a atividade
        palavras_atividade = palavras_chave_municipais.get(grupo_atividade, [])
        
        if not palavras_atividade:
            print(f"‚ö†Ô∏è Nenhuma palavra-chave espec√≠fica mapeada para '{grupo_atividade}'")
            return []
        
        legislacoes_municipais = []
        
        # üîç BUSCAR NAS LEIS REAIS CARREGADAS DE TODAS AS FONTES (INCLUINDO PINECONE)
        for lei in self.todas_fontes_data:
            # Filtrar apenas leis municipais (incluindo "Municipal - [Nome do Munic√≠pio]")
            jurisdicao = lei.get("jurisdicao", "").lower()
            if "municipal" not in jurisdicao:
                continue
            titulo_desc = (lei.get("titulo", "") + " " + lei.get("descricao", "")).lower()
            
            # üéØ VERIFICA√á√ÉO RIGOROSA: A lei deve conter palavra-chave espec√≠fica
            if any(palavra in titulo_desc for palavra in palavras_atividade):
                legislacoes_municipais.append({
                    "esfera": "Municipal",
                    "titulo_legislacao": lei.get("titulo", "Lei Municipal"),
                    "vigencia": "‚úÖ Vigente",
                    "descricao_resumida": lei.get("descricao", "")[:150] + "..." if len(lei.get("descricao", "")) > 150 else lei.get("descricao", ""),
                    "aplicabilidade": f"Aplic√°vel especificamente a atividades de {grupo_atividade.lower()} no munic√≠pio de {municipio}",
                    "fonte_dados": "Pinecone - Dados Reais"  # üîç TRANSPAR√äNCIA DE ORIGEM
                })
        
        # ‚úÖ Aguardando indexa√ß√£o de dados municipais reais no Pinecone
        # ‚úÖ AGORA USA APENAS DADOS REAIS DO PINECONE
        
        # ‚ö†Ô∏è APLICAR FILTRO DE VIG√äNCIA OBRIGAT√ìRIO
        legislacoes_vigentes = [
            leg for leg in legislacoes_municipais 
            if self._verificar_vigencia_legislacao(leg)
        ]
        
        print(f"üéØ Filtro restritivo aplicado: {len(legislacoes_vigentes)} leis municipais REAIS para '{grupo_atividade}' em {municipio}")
        print(f"üìä Fonte: 100% dados reais do Pinecone")
        print(f"‚ÑπÔ∏è Nota: Dados municipais espec√≠ficos ser√£o inclu√≠dos conforme indexa√ß√£o no Pinecone")
        return legislacoes_vigentes[:limite]

    def gerar_estrutura_tabela(self, descricao_usuario: str) -> Dict[str, Any]:
        """
        Gera a estrutura da tabela baseada na descri√ß√£o do usu√°rio
        usando IA direcionada da OpenAI
        """
        
        # Prompt direcionado APENAS para a gera√ß√£o da estrutura da tabela
        prompt_sistema = """
        Voc√™ √© uma IA especializada em organizar dados de leis ambientais em tabelas.
        Sua fun√ß√£o √© APENAS gerar estruturas de tabelas baseadas na descri√ß√£o do usu√°rio.
        
        REGRAS IMPORTANTES:
        1. Sempre retorne um JSON v√°lido
        2. Crie colunas relevantes para leis ambientais
        3. Seja espec√≠fico e pr√°tico
        4. N√£o invente dados, apenas estruture
        5. Use nomes de colunas claros e objetivos
        
        Formato de resposta obrigat√≥rio:
        {
            "titulo_tabela": "Nome da tabela",
            "descricao": "Breve descri√ß√£o do que a tabela organiza",
            "colunas": [
                {
                    "nome": "nome_coluna",
                    "tipo": "texto|numero|data|link",
                    "descricao": "O que esta coluna representa"
                }
            ],
            "filtros_sugeridos": ["filtro1", "filtro2"],
            "ordenacao_padrao": "nome_da_coluna"
        }
        """
        
        prompt_usuario = f"""
        Crie uma estrutura de tabela para organizar leis ambientais baseada nesta descri√ß√£o:
        
        "{descricao_usuario}"
        
        Considere que temos dados de leis com: t√≠tulo, descri√ß√£o, data, link do arquivo, conte√∫do parcial.
        Retorne APENAS o JSON da estrutura, sem explica√ß√µes adicionais.
        """
        
        try:
            client = OpenAI(
                api_key=self.api_key,
                timeout=60.0,  # Timeout de 60 segundos
                max_retries=3  # M√°ximo de 3 tentativas
            )
            
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": prompt_sistema},
                    {"role": "user", "content": prompt_usuario}
                ],
                temperature=0.3,  # Baixa criatividade para ser mais direcionado
                max_tokens=1000
            )
            
            resposta_ia = response.choices[0].message.content.strip()
            
            # Tentar extrair JSON da resposta
            if resposta_ia.startswith('```json'):
                resposta_ia = resposta_ia.replace('```json', '').replace('```', '').strip()
            
            estrutura = json.loads(resposta_ia)
            return estrutura
            
        except openai.APIConnectionError as e:
            print(f"‚ùå Erro de conex√£o com a API OpenAI: {e}")
            print("üí° Verifique sua conex√£o com a internet e tente novamente")
            return self._estrutura_padrao()
        except openai.APITimeoutError as e:
            print(f"‚ùå Timeout na API OpenAI: {e}")
            print("üí° A API demorou para responder, tente novamente")
            return self._estrutura_padrao()
        except openai.AuthenticationError as e:
            print(f"‚ùå Erro de autentica√ß√£o OpenAI: {e}")
            print("üí° Verifique se a OPENAI_API_KEY est√° correta no arquivo .env")
            return self._estrutura_padrao()
        except json.JSONDecodeError as e:
            print(f"‚ùå Erro ao decodificar JSON da IA: {e}")
            return self._estrutura_padrao()
        except Exception as e:
            print(f"‚ùå Erro na IA: {e}")
            # Retorna estrutura padr√£o em caso de erro
            return self._estrutura_padrao()
    
    def _estrutura_padrao(self) -> Dict[str, Any]:
        """Estrutura padr√£o de tabela em caso de erro"""
        return {
            "titulo_tabela": "Leis Ambientais - Organiza√ß√£o Padr√£o",
            "descricao": "Tabela b√°sica com informa√ß√µes das leis ambientais",
            "colunas": [
                {
                    "nome": "numero_lei",
                    "tipo": "texto",
                    "descricao": "N√∫mero da lei extra√≠do do t√≠tulo"
                },
                {
                    "nome": "titulo",
                    "tipo": "texto",
                    "descricao": "T√≠tulo completo da lei"
                },
                {
                    "nome": "ano",
                    "tipo": "numero",
                    "descricao": "Ano de publica√ß√£o da lei"
                },
                {
                    "nome": "tema_principal",
                    "tipo": "texto",
                    "descricao": "Tema principal da lei"
                },
                {
                    "nome": "link",
                    "tipo": "link",
                    "descricao": "Link para o arquivo da lei"
                }
            ],
            "filtros_sugeridos": ["ano", "tema_principal"],
            "ordenacao_padrao": "ano"
        }
    
    def gerar_tabela_vazia(self, estrutura: Dict[str, Any]) -> pd.DataFrame:
        """
        A IA gera uma tabela vazia baseada no prompt com a estrutura fornecida
        """
        colunas = [col["nome"] for col in estrutura["colunas"]]
        df_vazio = pd.DataFrame(columns=colunas)
        
        # Adicionar algumas linhas de exemplo vazias para visualiza√ß√£o
        for i in range(3):
            linha_vazia = {col: f"[{col}_{i+1}]" for col in colunas}
            df_vazio = pd.concat([df_vazio, pd.DataFrame([linha_vazia])], ignore_index=True)
        
        return df_vazio
    
    def popular_tabela(self, estrutura: Dict, num_documentos: int = 10, incluir_todas_fontes: bool = True) -> pd.DataFrame:
        """
        Popula a tabela com dados de todas as fontes ou apenas leis estaduais
        
        Args:
            estrutura: Estrutura da tabela definida pela IA
            num_documentos: N√∫mero de documentos a incluir na tabela
            incluir_todas_fontes: Se True, inclui todas as fontes; se False, apenas leis estaduais
            
        Returns:
            DataFrame populado com os dados
        """
        try:
            # Escolher fonte de dados
            if incluir_todas_fontes:
                dados_fonte = self.todas_fontes_data[:num_documentos]
                print(f"üìä Populando tabela com {len(dados_fonte)} documentos de TODAS as fontes")
            else:
                # Filtrar apenas leis estaduais dos dados do Pinecone
                dados_estaduais = [d for d in self.todas_fontes_data if d.get('jurisdicao', '').startswith('Estadual')]
                dados_fonte = dados_estaduais[:num_documentos]
                print(f"üìä Populando tabela com {len(dados_fonte)} leis estaduais do Pinecone")
            
            # Processar cada documento
            dados_processados = []
            for documento in dados_fonte:
                if incluir_todas_fontes:
                    dados_doc = self._extrair_dados_documento(documento)
                else:
                    dados_doc = self._extrair_dados_lei(documento, estrutura)
                dados_processados.append(dados_doc)
            
            # Criar DataFrame
            df = pd.DataFrame(dados_processados)
            
            # Ajustar colunas conforme estrutura solicitada
            colunas_estrutura = estrutura.get('colunas', [])
            if colunas_estrutura:
                df_ajustado = self._ajustar_colunas_estrutura(df, colunas_estrutura, incluir_todas_fontes)
                return df_ajustado
            
            return df
            
        except Exception as e:
            print(f"‚ùå Erro ao popular tabela: {e}")
            return pd.DataFrame()
    
    def _extrair_dados_documento(self, documento: Dict) -> Dict:
        """
        Extrai dados de um documento de qualquer fonte
        
        Args:
            documento: Dicion√°rio com dados do documento
            
        Returns:
            Dicion√°rio com dados extra√≠dos e padronizados
        """
        return {
            'fonte': documento.get('fonte', 'N/A'),
            'tipo': documento.get('tipo', 'N/A'),
            'titulo': documento.get('titulo', 'N/A'),
            'descricao': documento.get('descricao', 'N/A')[:200] + '...' if len(documento.get('descricao', '')) > 200 else documento.get('descricao', 'N/A'),
            'categoria': documento.get('categoria', 'N/A'),
            'jurisdicao': documento.get('jurisdicao', 'N/A'),
            'data_indexacao': documento.get('data_indexacao', 'N/A'),
            'conteudo': documento.get('conteudo', 'N/A')[:100] + '...' if len(documento.get('conteudo', '')) > 100 else documento.get('conteudo', 'N/A')
        }
    
    def _ajustar_colunas_estrutura(self, df: pd.DataFrame, colunas_estrutura: List[Dict], incluir_todas_fontes: bool) -> pd.DataFrame:
        """Ajusta as colunas do DataFrame conforme a estrutura solicitada"""
        df_ajustado = pd.DataFrame()
        
        for col_info in colunas_estrutura:
            nome_col = col_info.get('nome', '')
            
            if incluir_todas_fontes:
                # Mapeamento para dados de todas as fontes
                if nome_col.lower() in ['fonte', 'origem']:
                    df_ajustado[nome_col] = df.get('fonte', '')
                elif nome_col.lower() in ['tipo', 'categoria_documento']:
                    df_ajustado[nome_col] = df.get('tipo', '')
                elif nome_col.lower() in ['t√≠tulo', 'titulo']:
                    df_ajustado[nome_col] = df.get('titulo', '')
                elif nome_col.lower() in ['descri√ß√£o', 'descricao']:
                    df_ajustado[nome_col] = df.get('descricao', '')
                elif nome_col.lower() in ['categoria', 'classificacao']:
                    df_ajustado[nome_col] = df.get('categoria', '')
                elif nome_col.lower() in ['jurisdi√ß√£o', 'jurisdicao', 'abrangencia']:
                    df_ajustado[nome_col] = df.get('jurisdicao', '')
                elif nome_col.lower() in ['data', 'data_indexacao']:
                    df_ajustado[nome_col] = df.get('data_indexacao', '')
                else:
                    df_ajustado[nome_col] = df.get(nome_col.lower(), '')
            else:
                # Mapeamento para leis estaduais apenas
                if nome_col.lower() in ['t√≠tulo', 'titulo']:
                    df_ajustado[nome_col] = df.get('titulo', '')
                elif nome_col.lower() in ['descri√ß√£o', 'descricao']:
                    df_ajustado[nome_col] = df.get('descricao', '')
                elif nome_col.lower() == 'data':
                    df_ajustado[nome_col] = df.get('data', '')
                elif nome_col.lower() == 'link':
                    df_ajustado[nome_col] = df.get('link', '')
                elif nome_col.lower() in ['n√∫mero', 'numero']:
                    df_ajustado[nome_col] = df.get('numero', '')
                else:
                    df_ajustado[nome_col] = ''
        
        return df_ajustado
    
    def _extrair_dados_lei(self, lei: Dict, estrutura: Dict[str, Any] = None) -> Dict[str, str]:
        """
        Extrai dados espec√≠ficos de uma lei baseado na estrutura da tabela
        """
        dados_extraidos = {}
        
        for coluna in estrutura["colunas"]:
            nome_col = coluna["nome"]
            tipo_col = coluna["tipo"]
            
            # Mapeamento b√°sico de dados
            if nome_col in ["titulo", "t√≠tulo"]:
                dados_extraidos[nome_col] = lei.get("titulo", "")
            elif nome_col in ["descricao", "descri√ß√£o"]:
                dados_extraidos[nome_col] = lei.get("descricao", "")
            elif nome_col in ["data", "ano"]:
                data_lei = lei.get("data", "")
                if nome_col == "ano" and data_lei:
                    try:
                        dados_extraidos[nome_col] = data_lei.split("-")[0]
                    except:
                        dados_extraidos[nome_col] = ""
                else:
                    dados_extraidos[nome_col] = data_lei
            elif nome_col in ["link", "link_arquivo"]:
                dados_extraidos[nome_col] = lei.get("link_arquivo", "")
            elif nome_col in ["numero_lei", "numero"]:
                titulo = lei.get("titulo", "")
                # Extrair n√∫mero da lei do t√≠tulo
                import re
                match = re.search(r'Lei n¬∫ (\d+[./]\d+)', titulo)
                dados_extraidos[nome_col] = match.group(1) if match else ""
            else:
                # Para outras colunas, usar conte√∫do parcial ou descri√ß√£o
                dados_extraidos[nome_col] = lei.get("conteudo_parcial", "")[:50] + "..."
        
        return dados_extraidos
    
    def salvar_tabela(self, df: pd.DataFrame, estrutura: Dict[str, Any], formato: str = "excel") -> str:
        """
        Salva a tabela em diferentes formatos
        """
        titulo_arquivo = estrutura["titulo_tabela"].replace(" ", "_").lower()
        timestamp = pd.Timestamp.now().strftime("%Y%m%d_%H%M%S")
        
        # Usar path relativo ao diret√≥rio do projeto
        projeto_root = Path(__file__).parent.parent
        
        if formato == "excel":
            nome_arquivo = f"tabela_{titulo_arquivo}_{timestamp}.xlsx"
            caminho = projeto_root / nome_arquivo
            df.to_excel(caminho, index=False)
        elif formato == "csv":
            nome_arquivo = f"tabela_{titulo_arquivo}_{timestamp}.csv"
            caminho = projeto_root / nome_arquivo
            df.to_csv(caminho, index=False, encoding='utf-8')
        else:
            raise ValueError("Formato n√£o suportado. Use 'excel' ou 'csv'")
        
        return str(caminho)
    
    def gerar_relatorio_tabela(self, estrutura: Dict[str, Any], df: pd.DataFrame) -> str:
        """
        Gera um relat√≥rio sobre a tabela criada
        """
        relatorio = f"""
# üìä RELAT√ìRIO DA TABELA GERADA

## üìã Informa√ß√µes Gerais
- **T√≠tulo:** {estrutura['titulo_tabela']}
- **Descri√ß√£o:** {estrutura['descricao']}
- **Total de Linhas:** {len(df)}
- **Total de Colunas:** {len(df.columns)}

## üèóÔ∏è Estrutura da Tabela
"""
        
        for i, coluna in enumerate(estrutura['colunas'], 1):
            relatorio += f"""
### {i}. {coluna['nome'].title()}
- **Tipo:** {coluna['tipo']}
- **Descri√ß√£o:** {coluna['descricao']}
"""
        
        relatorio += f"""
## üîç Filtros Sugeridos
{', '.join(estrutura.get('filtros_sugeridos', []))}

## üìà Ordena√ß√£o Padr√£o
{estrutura.get('ordenacao_padrao', 'N√£o definida')}

## üìä Pr√©via dos Dados
```
{df.head().to_string()}
```
"""
        
        return relatorio


if __name__ == "__main__":
    """Teste do sistema de carregamento de dados"""
    print("üß™ TESTANDO SISTEMA DE CARREGAMENTO DE DADOS")
    print("=" * 60)
    
    try:
        # Inicializar o servi√ßo
        ia_tabela = IATabela()
        
        # Verificar carregamento das fontes (todos do Pinecone)
        dados_pinecone = ia_tabela.todas_fontes_data
        dados_estaduais = [d for d in dados_pinecone if d.get('jurisdicao', '').startswith('Estadual')]
        dados_federais = [d for d in dados_pinecone if d.get('jurisdicao') == 'Federal']
        dados_municipais = [d for d in dados_pinecone if d.get('jurisdicao', '').startswith('Municipal')]
        
        print(f"\nüìä RESUMO DOS DADOS CARREGADOS (PINECONE APENAS):")
        print(f"   ‚Ä¢ Leis Estaduais: {len(dados_estaduais)} documentos")
        print(f"   ‚Ä¢ Leis Federais: {len(dados_federais)} documentos")
        print(f"   ‚Ä¢ Leis Municipais: {len(dados_municipais)} documentos")
        print(f"   ‚Ä¢ Total de todas as fontes: {len(dados_pinecone)} documentos")
        
        # Verificar detalhes do EIA/RIMA
        if ia_tabela.leis_eia_rima and "leis_eia_rima" in ia_tabela.leis_eia_rima:
            print(f"\nüîç DETALHES EIA/RIMA:")
            for lei_info in ia_tabela.leis_eia_rima["leis_eia_rima"]:
                print(f"   ‚Ä¢ {lei_info.get('numero', 'N/A')}: {lei_info.get('titulo', 'Sem t√≠tulo')}")
        
        # Verificar Artigo 225
        if ia_tabela.constituicao_artigo_225:
            print(f"\nüìú ARTIGO 225:")
            for artigo in ia_tabela.constituicao_artigo_225:
                print(f"   ‚Ä¢ T√≠tulo: {artigo.get('titulo', 'N/A')}")
                print(f"   ‚Ä¢ URL: {artigo.get('url', 'N/A')}")
                break  # Apenas o primeiro (√∫nico) artigo
        
        print(f"\n‚úÖ TESTE CONCLU√çDO COM SUCESSO!")
        
    except Exception as e:
        print(f"‚ùå ERRO NO TESTE: {e}")
        import traceback
        traceback.print_exc()